var documenterSearchIndex = {"docs":
[{"location":"tutorials/Koopman/#Koopman","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"","category":"section"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"This tutorial will briefly introduce computing expectation values from orbits under uncertainty, using the Koopman  expectation introduced by DiffEqUncertainty.jl.[Gerlach2020]","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"[Gerlach2020]: A. R. Gerlach, A. Leonard, J. Rogers, and C. Rackauckas, “The Koopman Expectation: An Operator Theoretic Method for Efficient Analysis and Optimization of Uncertain Hybrid Dynamical Systems,” arXiv: 2008.08737, 2020.","category":"page"},{"location":"tutorials/Koopman/#Load-packages","page":"Koopman Expectation under Uncertainty","title":"Load packages","text":"","category":"section"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"First, we load all necessary packages:","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"using OrbitalTrajectories\nusing DifferentialEquations  # To propagate trajectories\nusing Plots                  # To plot trajectories\nusing Unitful                # Units (u\"km\", u\"d\" (days)) and unit conversion\nusing DiffEqUncertainty      # To compute the Koopman expectation\nusing Distributions          # To define uncertainty distributions\nnothing # hide","category":"page"},{"location":"tutorials/Koopman/#Differential-Correction","page":"Koopman Expectation under Uncertainty","title":"Differential Correction","text":"","category":"section"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"We begin with a Europa fly-by test case[Pellegrini2016] in the CR3BP (Jupiter-Europa) system:","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"[Pellegrini2016]: E. Pellegrini and R. P. Russell, “On the Computation and Accuracy of Trajectory State Transition Matrices,” Journal of Guidance, Control, and Dynamics, Vol. 39, No. 11, 2016, pp. 2485–2499, 10.2514/1.G001920.","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"system = CR3BP(:jupiter, :europa)\n\n# Periodic orbit around Jupiter with flybys of Europa\nu0 = [1.0486505808029702, 0., 0., 0., -0.09354853663949217, 0.]\nfull_tspan = (0., 37.)\nfull_state = State(system, u0, full_tspan)\nfull_trajectory = solve(full_state)\n\n# Truncate the trajectory to just a single flyby section\ntspan = (33., 37.)\nstate = State(system, full_trajectory.sol(tspan[1]), tspan)\ntrajectory = solve(state)\nplot(trajectory)","category":"page"},{"location":"tutorials/Koopman/#Uncertainty-in-Initial-State","page":"Koopman Expectation under Uncertainty","title":"Uncertainty in Initial State","text":"","category":"section"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"We can introduce some uncertainty in the initial state by specifying some distributions which define the uncertainty present in the initial values. Then, we can draw random samples from these to plot a statistical ensemble of trajectories (this is a form of Monte Carlo sampling).","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"# Define some Normal distributions for the initial values of x, y, and ẋ, ẏ\npos_stdev = uconvert(NoUnits, 100u\"km\" / system.props.L)\nvel_stdev = uconvert(NoUnits, 30u\"m/s\" / system.props.V)\nN_pos = [truncated(Normal(u, pos_stdev), u-3*pos_stdev, u+3*pos_stdev) for u in state.u0[1:2]]\nN_vel = [truncated(Normal(u, vel_stdev), u-3*vel_stdev, u+3*vel_stdev) for u in state.u0[4:5]]\n\n# New problems will be defined by randomly sampling from the above distributions\nprob_func(prob, i, r) = remake(prob, u0 = [rand.(N_pos)..., state.u0[3], rand.(N_vel)..., state.u0[6]])\n\n# Check for collisions with Europa\ncallback = collision(system, secondary_body(system))\n\n# Define and solve a probabilistic ensemble of these trajectories\nensemble = EnsembleProblem(state; prob_func)\ntrajectories = solve(ensemble, OrbitalTrajectories.Dynamics.DEFAULT_ALG, EnsembleThreads();\n                        trajectories=200, callback)\n\n# Plot the ensemble and original trajectory\np = plot(trajectories; alpha=0.1, arrow=true, color_palette=:linear_blue_5_95_c73_n256, nomodel=true)\nplot!(p, trajectory; c=:black, lw=3)","category":"page"},{"location":"tutorials/Koopman/#Computing-Expectations-(Monte-Carlo)","page":"Koopman Expectation under Uncertainty","title":"Computing Expectations (Monte Carlo)","text":"","category":"section"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"Note that some of the random trajectories crash into the secondary body (Europa). We would like to compute the expectation (i.e. average) for the likelihood that our trajectory will crash into the secondary body, given the uncertainties defined for its initial state.","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"The first way is to compute this from our Monte Carlo samples:","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"# Compute the running mean probability of crashing from the Monte Carlo samples\n# NOTE: This uses the `crashed()` function from OrbitalTrajectories.\ncollision_prob_MC = cumsum(map(crashed, trajectories)) ./ (1:length(trajectories))\np = plot(collision_prob_MC; label=\"Monte Carlo expectation\",\n            xlabel=\"Monte Carlo simulations\", ylabel=\"Collision probability (%)\")","category":"page"},{"location":"tutorials/Koopman/#Computing-Expectations-(Koopman)","page":"Koopman Expectation under Uncertainty","title":"Computing Expectations (Koopman)","text":"","category":"section"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"Alternatively, we can use the Koopman() operator from the DiffEqUncertainty.jl library to compute the expectation directly, without needing to sample from the statistical distribution of trajectories above.","category":"page"},{"location":"tutorials/Koopman/","page":"Koopman Expectation under Uncertainty","title":"Koopman Expectation under Uncertainty","text":"# Define the initial uncertain state, which just contains Normally-distributed and constant values\nu0_uncertain = [N_pos..., state.u0[3], N_vel..., state.u0[6]]\n\n# Compute the true expectation value for `crashed()` function using the Koopman operator\ncollision_prob_Koopman = expectation(crashed, state.prob, u0_uncertain, state.p, Koopman(),\n                            OrbitalTrajectories.Dynamics.DEFAULT_ALG; callback)\n\n# Plot the Koopman collision probability\nhline!(p, [collision_prob_Koopman.u]; label=\"Koopman expectation\")","category":"page"},{"location":"tutorials/QSOFamilies/#QSOs","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"","category":"section"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"This tutorial will briefly introduce computing parametrised families of Quasi-Satellite Orbits (QSOs) in any of the astrodynamical models provided by OrbitalTrajectories.jl.","category":"page"},{"location":"tutorials/QSOFamilies/#Load-packages","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Load packages","text":"","category":"section"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"First, we load all necessary packages:","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"using OrbitalTrajectories\nusing DifferentialEquations  # To propagate trajectories\nusing Plots                  # To plot trajectories\nusing LinearAlgebra          # To compute stability index (eigenvalue)","category":"page"},{"location":"tutorials/QSOFamilies/#Differential-Correction","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Differential Correction","text":"","category":"section"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"We can correct an initial guess trajectory to find an axisymmetric orbit.[Russell2006] We begin with an initial guess in a CR3BP (Mars-Phobos) system:","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"[Russell2006]: R. P. Russell, “Global search for planar and three-dimensional periodic orbits near Europa,” The Journal of the Astronautical Sciences, Vol. 54, No. 2, 2006, pp. 199–226, 10.1007/BF03256483. ","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"# Initial guess state\nu0 = [0.994, 0., 0., 0., 0.0117, 0.]\nstate = State(CR3BP(:mars, :phobos), u0, (0., 2π))\ntrajectory = solve(state)\np = plot(trajectory; color=:blue, alpha=0.25)","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"We can correct this initial guess using a DiffCorrectAxisymmetric corrector:","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"trajectory = solve(state, DiffCorrectAxisymmetric())\nplot!(p, trajectory; color=:blue)","category":"page"},{"location":"tutorials/QSOFamilies/#Parameter-Continuation-for-DRO/QSO-Orbit-Families","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Parameter Continuation for DRO/QSO Orbit Families","text":"","category":"section"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"Simple parameter continuation works by beginning with a known orbit, then perturbing it very slightly and correcting it to find a similar orbit. Here, we use continuation_simple to perturb our orbit along its initial x-axis position, returning a set of many similar orbits along the axis.","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"warning: Current limitations of `continuation_simple`\nNote that the continuation_simple method is not currently designed to be robust. It will only look for orbits that satisfy several conditions, such as x_0 in (R_1 - mu 1 - mu) (given the primary body's normalised x radius of R_1) and x_f in (1 - mu infty) (for the final x-crossing position). Thus, it will essentially only look for and find orbits like DROs/QSOs, perturbing only along the initial x position.","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"trajectories = continuation_simple(state; x_perturbation=3e-4, dc_tolerance=1e-4)\nlength(trajectories)","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"The example above returned a large number of orbits, so to make plotting faster, we only plot every 10th orbit using the 1:10:end selector. In addition, we also provide a values array to provide a colour to each individual orbit depending on its stability index.","category":"page"},{"location":"tutorials/QSOFamilies/","page":"Families of Quasi-Satellite Orbits (QSOs)","title":"Families of Quasi-Satellite Orbits (QSOs)","text":"selected_trajectories = trajectories[1:10:end]\n\n# Compute stability index for each orbit\nstability_index = map(selected_trajectories) do traj\n    STM = Matrix(sensitivity(AD, State(traj)))\n    eigenvalues = norm.(eigvals(STM))\n    return maximum(eigenvalues)\nend\n\n# Propagate each trajectory to a full orbit\nfull_orbits = [\n    solve(remake(State(traj); tspan=(traj.t[begin], traj.t[end] * 2.)))\n    for traj in selected_trajectories\n]\n\n# Plot the orbit family, coloured by its stability index\nplot(full_orbits; values=stability_index, primary_color=:red, legend=:bottomleft)","category":"page"},{"location":"tutorials/SunMarsCR3BP/#SunMars_cr3bp_orbits","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"","category":"section"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"This tutorial will briefly introduce propagating and plotting orbits in the Circular Restricted 3-Body Problem (CR3BP).","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"Here, we will reproduce Figure 4 from a Mars ballistic capture paper[DeiTos2018], which plots a few different types of periodic orbits in the Sun-Mars 3-body system.","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"[DeiTos2018]: Diogene A. Dei Tos, Ryan P. Russell, and Francesco Topputo, \"Survey of Mars Ballistic Capture Trajectories Using Periodic Orbits as Generating Mechanisms\", Journal of Guidance, Control, and Dynamics 2018 41:6, 1227-1242","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"note: Coding style\nNote that we've split this example into individual steps, and purposefully introduced the use of Julia Dictionaries, Arrays, NamedTuples, and so on. In actual code, you should be able to simplify this code as desired.","category":"page"},{"location":"tutorials/SunMarsCR3BP/#Load-packages","page":"Sun-Mars CR3BP periodic orbits","title":"Load packages","text":"","category":"section"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"First, we load all necessary packages:","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"using OrbitalTrajectories\nusing DifferentialEquations  # To propagate trajectories\nusing Plots                  # To plot trajectories\nusing Unitful                # Units (u\"km\", u\"d\" (days)) and unit conversion","category":"page"},{"location":"tutorials/SunMarsCR3BP/#Compute-initial-y-velocity-given-a-Jacobi-energy","page":"Sun-Mars CR3BP periodic orbits","title":"Compute initial y-velocity given a Jacobi energy","text":"","category":"section"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"The orbit parameters given in the paper are the initial x-axis crossing position (in 10^6km from Mars) and Jacobi energy J (non-dimensional).","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"First, we compute the initial state vector by normalising the initial x position (x0), then computing the initial y-velocity (v0) from the Jacobi energy.","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"We return a new spacecraft State(@ref) with the initial state (given x0 and v0) and expected propagation time (which we set to some default tmax value, noting that it is normalised to radians for the CR3BP model).","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"function compute_initial_state(system; x0, J, tmax=365u\"d\")\n    x0 = 1 - system.props.μ + (x0*(10^6)u\"km\" / system.props.L)\n    v0 = √(2*centrifugal_potential(system.props.μ, [x0, 0., 0.]) - J)\n    State(system, [x0, 0., 0., 0., v0, 0.], (0, tmax / system.props.T))\nend","category":"page"},{"location":"tutorials/SunMarsCR3BP/#Create-initial-states","page":"Sun-Mars CR3BP periodic orbits","title":"Create initial states","text":"","category":"section"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"Now we create the initial states by mapping our function above to the set of orbit parameters given in the paper. Note that our initial states are guesses; they are not completely numerically accurate, and therefore will not lead to periodic orbits.","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"SunMars = CR3BP(:sun, :mars)\n\nall_params = Dict(\n    \"g2\" => [\n        (x0 = 0.172, J = 3.000034),  # updated to get a similar trajectory\n        (x0 = 0.432, J = 3.000118),\n        (x0 = 0.556, J = 3.000203),\n        (x0 = 0.775, J = 3.000203),\n        (x0 = 0.841, J = 3.0001804), # highly sensitive, updated to similar\n    ],\n    \"g1\" => [\n        (x0 = 0.006, J = 3.011712, tmax=1u\"d\"),\n        (x0 = 0.198, J = 3.000410),\n        (x0 = 0.161, J = 3.000203),\n        (x0 = 0.081, J = 3.000203),\n        (x0 = 0.027, J = 3.000196), # highly sensitive, updated to similar\n    ],\n    \"DRO\" => [\n        (x0 = -0.008, J = 3.009513, tmax=1u\"d\"),\n        (x0 = -0.256, J = 3.000255),\n        (x0 = -0.944, J = 3.000015),\n    ]\n)\n\n# Map the compute_initial_state function to all the parameters in each family above\nall_states = Dict(family => begin\n    [compute_initial_state(SunMars; p...) for p in params]\nend for (family, params) in all_params)\nnothing # hide","category":"page"},{"location":"tutorials/SunMarsCR3BP/#Propagate-and-plot-a-trajectory","page":"Sun-Mars CR3BP periodic orbits","title":"Propagate and plot a trajectory","text":"","category":"section"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"We can see an example trajectory arising from one of our initial state guesses by propagating it with the default propagator options, and then plotting it. Let's try to plot the first orbit in the \"g2\" family:","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"trajectory = solve(all_states[\"g2\"][1])\np1 = plot(trajectory)","category":"page"},{"location":"tutorials/SunMarsCR3BP/#Correct-the-orbits-into-periodic-orbits","page":"Sun-Mars CR3BP periodic orbits","title":"Correct the orbits into periodic orbits","text":"","category":"section"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"We will now find the exact periodic orbits corresponding to our initial state guesses by using an axisymmetric single-shooting differential corrector scheme. This is done simply by solving our states using the DiffCorrectAxisymmetric(@ref) corrector.","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"all_half_orbits = Dict(family => begin\n    [solve(s, DiffCorrectAxisymmetric()) for s in states]\nend for (family, states) in all_states)","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"note: Differential corrector orbits\nNote that DiffCorrectAxisymmetric differential corrector orbits are returned propagated only for half their period (i.e. until the x-axis crossing).","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"Now, we can super-impose this corrected trajectory on our previous plot:","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"plot!(p1, all_half_orbits[\"g2\"][1]; color=:blue)","category":"page"},{"location":"tutorials/SunMarsCR3BP/#Propagate-and-plot-full-periodic-orbits","page":"Sun-Mars CR3BP periodic orbits","title":"Propagate and plot full periodic orbits","text":"","category":"section"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"Finally, we end by propagating our all_half_orbits above for a full orbital period each, and plot them.","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"plots = Dict(family => begin\n    # half_orbits are given in the (0., t[end]) timespan.\n    # We convert these to full orbits by propagating them in the (0., t[end]*2) timespan.\n    orbits = [solve(remake(State(o), tspan=(0., o.t[end] * 2))) for o in half_orbits]\n\n    # Plot each of the orbits individually.\n    plots = [plot(o; color=:blue) for o in orbits]\n\n    # Plot the whole family as a single row.\n    plot(plots...; layout=(1, length(plots)))\nend for (family, half_orbits) in all_half_orbits)\nnothing # hide","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"Now we can plot the full figure by laying out our plots appropriately:","category":"page"},{"location":"tutorials/SunMarsCR3BP/","page":"Sun-Mars CR3BP periodic orbits","title":"Sun-Mars CR3BP periodic orbits","text":"plot(plots[\"g2\"], plots[\"g1\"], plots[\"DRO\"]; layout=(3, 1),\n     legend=false, grid=false, minorgrid=false, showaxis=false, size=(500,500))","category":"page"},{"location":"tutorials/DynamicModels/#dynamical_models","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"","category":"section"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"This tutorial will briefly introduce propagating and plotting orbits in the astrodynamical models provided by OrbitalTrajectories.jl","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"Here, we will reproduce Figure 3 from the OrbitalTrajectories.jl paper[Padilha2021], which shows example trajectories in the Earth-Moon(-Sun) system.","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"[Padilha2021]: Dan Padilha, Diogene A. Dei Tos, Nicola Baresi, Junichiro Kawaguchi, \"Modern Numerical Programming with Julia for Astrodynamic Trajectory Design\", 31st AAS/AIAA Space Flight Mechanics Meeting, 2021.","category":"page"},{"location":"tutorials/DynamicModels/#Load-packages","page":"Astrodynamical Models","title":"Load packages","text":"","category":"section"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"First, we load all necessary packages:","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"using OrbitalTrajectories\nusing DifferentialEquations  # To propagate trajectories\nusing Plots                  # To plot trajectories\nusing Unitful                # Units (u\"km\", u\"d\" (days)) and unit conversion","category":"page"},{"location":"tutorials/DynamicModels/#Build-astrodynamical-models","page":"Astrodynamical Models","title":"Build astrodynamical models","text":"","category":"section"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"We build a set of astrodynamical models (systems) in the Earth-Moon(-Sun) system. This includes:","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"Circular Restricted 3-Body Problem (CR3BP) for Earth-Moon\nElliptic Restricted 3-Body Problem (ER3BP) for Earth-Moon\nBi-Circular Restricted 4-Body Problem (BC4BP) for Earth-Moon-Sun\nEphemeris Restricted N-Body Problem (EphemerisNBP) for Earth-Moon-Sun","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"a, b, c = (:Earth, :Moon, :Sun)\n\n# The EphemerisNBP model requires a timespan in seconds, rather than radians.\ntspan       = (0.88π, 2.83π)\ntspan_epoch = ustrip.(u\"s\", tspan .* R3BPSystemProperties(a, b).T)\n\n# Define the systems to test.\n# xoffset/yoffset are used to offset the model labels in the resulting plot.\nsystems = Dict(\n  CR3BP(a, b)           => (color=:blue,   tspan=(0.88π, 2.88π), xoffset=-0.06, yoffset=-0.04),\n  ER3BP(a, b)           => (color=:red,    tspan=(0.88π, 3.00π), xoffset=-0.06, yoffset=-0.04),\n  BC4BP(a, b, c)        => (color=:green,  tspan=(0.88π, 2.85π), xoffset=-0.05, yoffset=-0.06),\n  EphemerisNBP(a, b, c) => (color=:orange, tspan=tspan_epoch,    xoffset=-0.20, yoffset=-0.02)\n)\nnothing # hide","category":"page"},{"location":"tutorials/DynamicModels/#Initial-state-and-reference-frame","page":"Astrodynamical Models","title":"Initial state and reference frame","text":"","category":"section"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"We specify an initial state simply as a vector of x_0 y_0 z_0 dotx_0 doty_0 dotz_0. The state we provide is defined in a normalised synodic rotating frame, so we specify the initial frame as SynodicFrame().","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"u0       = [0.76710535, 0., 0., 0., 0.47262724, 0.]\nu0_frame = SynodicFrame()\nnothing # hide","category":"page"},{"location":"tutorials/DynamicModels/#Simple-propagation-and-plotting","page":"Astrodynamical Models","title":"Simple propagation and plotting","text":"","category":"section"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"We can propagate a trajectory by creating an initial state object State, providing the desired astrodynamical model (sys), initial state vector (u0), initial state reference frame (u0_frame), and propagation timespan (tspan).","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"To propagate, we simply call solve(state).","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"For example, to plot in the Circular Restricted 3-Body Problem (CR3BP):","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"# Create the initial state\nstate = State(CR3BP(:Earth, :Moon), u0_frame, u0, tspan)\n\n# Propagate the state to compute a trajectory\ntrajectory = solve(state)\n\n# Plot the trajectory\nplot(trajectory; legend=:bottomright)","category":"page"},{"location":"tutorials/DynamicModels/#Propagate-and-plot-in-all-the-models","page":"Astrodynamical Models","title":"Propagate and plot in all the models","text":"","category":"section"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"Here we propagate and plot trajectories in all of the aforementioned models.","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"First, set up some plotting options as follows.","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"plot_attrs = (thickness_scaling=0.75, legendfontsize=9, tickfontsize=9, guidefontsize=10,\n              titlefontsize=10, bg_color_legend=RGBA(1, 1, 1, 0.8), fg_color_legend=nothing,\n              legend=:bottomright)\np = plot();\n\n# Keep track of the maximum x and y limits\nxlim = (Inf, -Inf)\nylim = (Inf, -Inf)\nnothing # hide","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"To plot in the original reference frame (i.e. normalised synodic rotating frame), we simply call plot(trajectory, u0_frame).","category":"page"},{"location":"tutorials/DynamicModels/","page":"Astrodynamical Models","title":"Astrodynamical Models","text":"for (i, (sys, opts)) in enumerate(systems)\n    # Create the initial state\n    state = State(sys, u0_frame, u0, opts.tspan)\n\n    # Propagate it to compute the trajectory\n    trajectory = solve(state)\n\n    # Plot the trajectory\n    plot!(p, trajectory, u0_frame; label=\"\", color=opts.color, nolabels=(i!=1))\n\n    # Add a label for the model name\n    traj_converted = convert_to_frame(trajectory, u0_frame)\n    annotate!(p, [(traj_converted.sol[end][1] + opts.xoffset,\n                   traj_converted.sol[end][2] - opts.yoffset,\n                   Plots.text(\"$(nameof(typeof(sys)))\" * \n                    ((isa(sys, EphemerisNBP) || isa(sys, BC4BP)) ? \"\\n(+ $(String(c)))\" : \"\"),\n                   opts.color, :left, 9, 0.))]);\n\n    # Add a label for barycenter\n    (i == 1) && hline!(p, [0.]; linecolor=:black, linestyle=:solid,\n                       label=\"$(titlecase(String(a)))-$(titlecase(String(b))) Barycenter\")\n    \n    # Expand the plot limits to the biggest size\n    global xlim, ylim  # we want to override the global variables outside this scope\n    xlim = (min(xlim[1], xlims()[1]), max(xlim[2], xlims()[2]))\n    ylim = (min(ylim[1], ylims()[1]), max(ylim[2], ylims()[2]))\n    plot!(p; xlims=xlim, ylims=ylim, plot_attrs...)\nend\np  # Display the final plot","category":"page"},{"location":"tutorials/STM/#STMs","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"","category":"section"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"This tutorial will briefly introduce computing and plotting State Transition Matrices (STMs) for any of the astrodynamical models provided by OrbitalTrajectories.jl.","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"Here, we will reproduce Figure 4 from the OrbitalTrajectories.jl paper[Padilha2021], which shows example trajectories and traces out the maximum eigenvalue of their STMs.","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"[Padilha2021]: Dan Padilha, Diogene A. Dei Tos, Nicola Baresi, Junichiro Kawaguchi, \"Modern Numerical Programming with Julia for Astrodynamic Trajectory Design\", 31st AAS/AIAA Space Flight Mechanics Meeting, 2021.","category":"page"},{"location":"tutorials/STM/#Load-packages","page":"State Transition Matrices (STMs)","title":"Load packages","text":"","category":"section"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"First, we load all necessary packages:","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"using OrbitalTrajectories\nusing DifferentialEquations  # To propagate trajectories\nusing Plots                  # To plot trajectories\nusing LinearAlgebra          # To compute matrix eigenvalues","category":"page"},{"location":"tutorials/STM/#Orbit-data","page":"State Transition Matrices (STMs)","title":"Orbit data","text":"","category":"section"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"We build a structure to store the orbit data necessary. This data comes from Table 1 of this paper.[Pellegrini2016] Note that we include the Sun as a (fourth) body for higher-order propagation in BC4BP and EphemerisNBP.","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"[Pellegrini2016]: Etienne Pellegrini, Ryan P. Russell, \"On the Computation and Accuracy of Trajectory State Transition Matrices\", Journal of Guidance, Control, and Dynamics, Vol. 39 Issue 11, Pg. 2485-2499, 2016, DOI:10.2514/1.G001920.","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"test_cases = [(\n    system = (:Jupiter, :Europa, :Sun),\n    u0     = [-0.1017472008677258, 0., 0., 0., -0.01806028472285857, 0.],\n    μ      = 2.528009215182033e-5,\n    t_p    = 25.13898226959327,\n    λ_max  = 2.468621114047195,\n    plot_args = (label=\"7:4 resonant\\n(Jupiter-Europa)\", xlim=(-1.15, 1.07))\n), (\n    system = (:Jupiter, :Europa, :Sun),\n    u0     = [0.04867586089512202, 0., 0., 0., -0.09354853663949217, 0.],\n    μ      = 2.528009215182033e-5,\n    t_p    = 70.53945041512506,\n    λ_max  = 2.804814246519340e7,\n    plot_args = (label=\"8:11 + flybys\\n(Jupiter-Europa)\", xlim=(-1.37, 1.35))\n), (\n    system = (:Earth, :Moon, :Sun),\n    u0     = [-0.013059020050628, 0., 0.07129515195874, 0., -0.526306975588415, 0.],\n    μ      = 0.01215509906405700,\n    t_p    = 2.517727406553485,\n    λ_max  = 17.632688124231755,\n    plot_args = (label=\"L1 halo orbit\\n(Earth-Moon)\", xlim=(0.8, 1.015))\n)]\nnothing # hide","category":"page"},{"location":"tutorials/STM/#Propagate-and-plot-trajectory","page":"State Transition Matrices (STMs)","title":"Propagate & plot trajectory","text":"","category":"section"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"For demonstration, we first propagate and plot one of the test cases above in the Circular Restricted 3-Body Problem (CR3BP).","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"case = test_cases[1]  # Pick the first test case\n\n# Build the system\n# NOTE: overriding the default mass parameter μ with the one provided by [Pellegrini2016]\nsystem = CR3BP(case.system[1:2]...; μ=case.μ)\n\n# Propagation timespan\nt_init = π/4  # Arbitrary initial time, does not matter for CR3BP\ntspan  = (t_init, t_init + case.t_p)\n\n# Initial state vector in [Pellegrini2016] is relative to secondary body\nu0 = copy(case.u0)\nu0[1] += 1 - case.μ\n\n# Build the initial state and propagate it\nstate = State(system, SynodicFrame(), u0, tspan)\ntrajectory = solve(state)\nplot(trajectory; legend=:bottomleft, case.plot_args...)","category":"page"},{"location":"tutorials/STM/#Compute-State-Transition-Matrix-(STM)","page":"State Transition Matrices (STMs)","title":"Compute State Transition Matrix (STM)","text":"","category":"section"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"We can compute the STM using one of several methods:","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"Automatic Differentiation (AD) – using the ForwardDiff package.\nFinite Differencing (FD) – using the FiniteDiff package.\nSymbolic Variational Equations (VE) – using the ModelingToolkit package.\nHand-coded Variational Equations (VE) – when using the HandcodedCR3BP model.","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"Each of the above methods is implemented in OrbitalTrajectories.jl. Below, we demonstrate how to use the Automatic Differentiation (AD) method to compute and plot the STM:","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"# Compute the STM at the final point of the trajectory (with respect to initial state)\nSTM = sensitivity(AD, state)","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"We can check that the stability index (maximum eigenvalue) matches the value from the paper.[Pellegrini2016]","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"# Check if STM eigenvalues matches what [Pellegrini2016] gives\nλ_max = maximum(norm.(eigvals(Matrix(STM))))\n@assert isapprox(λ_max, case.λ_max; rtol=1e-5)","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"We can also compute and plot the STM along the full trajectory. Note that this trace is also interpolatable at any point.","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"# Compute the STM trace (i.e. the STM at every point along the trajectory)\nSTM_trace = sensitivity_trace(AD, state)\n\n# Plot the STM elements\nplot(STM_trace; trace=true)","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"We can also plot the stability index directly:","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"# Plot the STM stability index (i.e. maximum eigenvalue)\nplot(STM_trace; trace_stability=true)","category":"page"},{"location":"tutorials/STM/#Plot-all-the-trajectories-and-STM-stability-traces","page":"State Transition Matrices (STMs)","title":"Plot all the trajectories and STM stability traces","text":"","category":"section"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"The models we will test are the following:","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"models = (EphemerisNBP, BC4BP, ER3BP, CR3BP, HandcodedCR3BP)\nnothing # hide","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"The test cases are plotted and traced for each of the above models as follows.","category":"page"},{"location":"tutorials/STM/","page":"State Transition Matrices (STMs)","title":"State Transition Matrices (STMs)","text":"using Unitful                # Units (u\"km\", u\"d\" (days)) and unit conversion\nusing LaTeXStrings           # So we can use Latex formatting in strings\nusing Plots.PlotMeasures     # To change plot margins using \"mm\" units\n\nframe = SynodicFrame()\nplot_attrs = (legendfontsize=8, titlefontsize=10, bg_color_legend=RGBA(1, 1, 1, 0.5), fg_color_legend=nothing)\n\np_orbits = []\np_traces = []\n\nfor (j, case) in enumerate(test_cases)\n    push!(p_orbits, plot())\n    push!(p_traces, plot())\n\n    for (i, model) in enumerate(models)\n        if model == HandcodedCR3BP || model <: Union{CR3BP, ER3BP}\n            bodies = case.system[1:2]\n            system = model(bodies...; μ=case.μ)\n        else\n            system = model(case.system...)\n        end\n\n        # Plotting options for this model\n        sys_name = String(nameof(typeof(system))) * (isa(system, CR3BP{true}) ? \" (hand-coded)\" : \"\")\n        alpha = isa(system, CR3BP) ? 1. : 0.7\n        VE_label = \" only\"\n\n        # Set an appropriate timespan\n        t_init = π/4  # arbitrary initial epoch\n        tspan = (t_init, t_init + case.t_p)\n        if isa(system, EphemerisNBP)\n            # tspan[1] is effectively an arbitrarily-chosen initial epoch time\n            props = R3BPSystemProperties(primary_body(system), secondary_body(system))\n            tspan = (tspan[1], case.t_p * ustrip(u\"s\", props.T) + tspan[1])\n            alpha = 1.0\n        end\n\n        # Convert initial state relative to secondary body --> relative to primary body\n        u0 = copy(case.u0)\n        u0[1] += 1 - case.μ\n\n        # Generate initial state and trajectory\n        state = State(system, frame, u0, tspan)\n        traj = solve(state)\n\n        # Plot the trajectory\n        color = [:orange, :green, :red, :blue, :black][i]\n        !isa(system, CR3BP{true}) && plot!(p_orbits[end], traj, frame; arrow=false, title=case.plot_args.label,\n            linewidth=isa(system, CR3BP{false}) ? 1.5 : 1, color, label=\"\", alpha, nolabels=true,\n            origin_secondary=false, case.plot_args..., plot_attrs...)\n\n        # Build trace using Variational Equations (VE)\n        if has_variational_equations(typeof(state))\n            traj_VE = sensitivity_trace(VE, state, frame)\n            VE_label = \" & VE\"\n\n            # Extract the sensitivities\n            tspan = range(traj_VE.t[begin], traj_VE.t[end], length=1000)\n            tnorm = range(0., 1., length=length(tspan))\n            u_vals = traj_VE.sol.(tspan)\n            dim = length(state.u0)\n            eigenvalues = eigvals.([reshape(ut[dim+1:end], (dim, dim)) for ut in u_vals])\n            stability_indices = map(x -> maximum(norm.(x)), eigenvalues)\n\n            # Plot!\n            !isa(system, CR3BP{true}) && plot!(p_traces[end], tnorm, stability_indices; linestyle=:dash, color, label=\"\", alpha)\n        end\n        VE_label = isa(system, CR3BP{false}) ? \"$(VE_label) & hand-coded\" : VE_label\n\n        # Build trace using Automatic Differentiation (AD)\n        traj_AD = sensitivity_trace(AD, state, frame)\n        !isa(system, CR3BP{true}) && plot!(p_traces[end], traj_AD, frame; trace_stability=true, label=\"$(sys_name) (AD$(VE_label))\", color,\n            link=:y, yscale=:log10, ylabel=(j == 1) ? L\"$\\lambda_{\\max}(\\textrm{STM})$\" : \"\", ytickfontcolor=(j == 1) ? RGBA(0,0,0,1) : RGBA(0,0,0,0),\n            ytickfontsize=(j == 1) ? 8 : 0, ygrid=true, legend=(j==1) ? :topleft : false, alpha, plot_attrs...)\n        j == 2 && plot!(p_traces[end]; xlabel=\"Time (normalised to 1 period)\")\n        \n        # Build trace using Finite Differencing (FD)\n        STM_FD = Matrix(sensitivity(FD, state, frame))\n        λ_max_FD = maximum(norm.(eigvals(STM_FD)))\n        isa(system, CR3BP{false}) && scatter!(p_traces[end], [1.], [λ_max_FD]; color=:black, markersize=6, markerstrokewidth=0, markershape=:star5, \n            label=L\"$\\lambda_{\\max,\\textrm{end}}\\;\\textrm{(FD)}$\")\n        !isa(system, CR3BP{true}) && scatter!(p_traces[end], [1.], [λ_max_FD]; color, markersize=6, markerstrokewidth=0, markershape=:star5, label=\"\")\n    end\nend\n\n# Plot: trajectories and STM traces\nplot(p_orbits..., p_traces...; layout=(2,3), thickness_scaling=0.75, left_margin=2mm, right_margin=4mm)","category":"page"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"(Image: OrbitalTrajectories.jl)","category":"page"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"OrbitalTrajectories.jl is a modern orbital trajectory design library for Julia, providing tools and methods for the design, optimisation, and analysis of astrodynamical models and spacecraft trajectories.","category":"page"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"warning: In Development\nOrbitalTrajectories.jl and its documentation is currently in development and is provided as a pre-1.0 release. Please refer to the examples/tutorials provided, and feel free to provide feedback to the package maintainers.","category":"page"},{"location":"#Getting-Started","page":"OrbitalTrajectories.jl","title":"Getting Started","text":"","category":"section"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"Install the package with add OrbitalTrajectories in Julia's package mode (run the Julia console and press ], or alternatively using Pkg; Pkg.add(\"OrbitalTrajectories\")).","category":"page"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"To later update to the newest release, simply do update OrbitalTrajectories.","category":"page"},{"location":"#Features","page":"OrbitalTrajectories.jl","title":"Features","text":"","category":"section"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"High-performance and highly accurate trajectory propagation in several astrodynamical models:\nComposable models built directly from symbolic mathematical equations of motion\nCompiled performance equivalent or exceeding that of MATLAB/Fortran competitors\nHigh-order interpolation of resulting trajectories\nDynamic conversions between inertial and rotating reference frames\nImplemented astrodynamical models:\nCircular Restricted 3-Body Problem (ER3BP)\nElliptic Restricted 3-Body Problem (ER3BP)\nBi-Circular Restricted 4-Body Problem (BC4BP)\nRestricted N-Body Problem (EphemerisNBP)\nBody states computed from NASA NAIF (SPICE) ephemerides downloaded automatically as needed\nAutomatic SPICE dynamic reference frames built for conversions\nDifferentiable models supporting computation of State Transition Matrices (STMs) using:\nFast, accurate Automatic Differentiation (AD) for every model\nSymbolically computed Variational Equations (VE) for some models\nHand-tuned variational equations for CR3BP model\nGeneric single-shooting differential corrector, supporting:\nFinding axisymmetric (quasi-)periodic orbits in every model\nSimple parameter continuation for computing families of orbits\nPlotting recipes\nPlot trajectories in inertial/rotating frames\nShow primary body, secondary body, and libration points\nPlot orbit families with custom-valued colourbars\nSupport for using Julia's highly-composable state-of-the-art ecosystem for optimisation, machine learning, statistical analysis, uncertainty quantification, and much more","category":"page"},{"location":"#License-and-References","page":"OrbitalTrajectories.jl","title":"License & References","text":"","category":"section"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"Distributed under the Apache License 2.0","category":"page"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"Copyright 2021 Dan Padilha (dpadilha.com)","category":"page"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"If you use OrbitalTrajectories.jl in a scientific project that leads to a publication, we'd appreciate you citing our paper as follows:","category":"page"},{"location":"","page":"OrbitalTrajectories.jl","title":"OrbitalTrajectories.jl","text":"@inproceedings{OrbitalTrajectories,\n  url = {https://www.researchgate.net/publication/348929030_Modern_Numerical_Programming_with_Julia_for_Astrodynamic_Trajectory_Design},\n  year = {2021},\n  publisher = {AAS/AIAA},\n  author = {Padilha, Dan and Dei Tos, Diogene Alessandro and Baresi, Nicola and Kawaguchi, Junichiro},\n  title = {Modern Numerical Programming with Julia for Astrodynamic Trajectory Design},\n  booktitle = {31st AAS/AIAA Space Flight Mechanics Meeting}\n}","category":"page"},{"location":"API/","page":"Package API","title":"Package API","text":"warning: In Development\nOrbitalTrajectories.jl and its documentation is currently in development and is provided as a pre-1.0 release.The interfaces (exported types/functions) here may, and most likely will, change in future updates, possibly breaking any existing code using OrbitalTrajectories.jl.While these interfaces are being developed, the documentation provided here is of very limited use. For now, please instead refer to the tutorials/examples which will be kept up-to-date as best as possible.","category":"page"},{"location":"API/","page":"Package API","title":"Package API","text":"Modules = [OrbitalTrajectories, OrbitalTrajectories.Dynamics, OrbitalTrajectories.SpiceUtils]","category":"page"},{"location":"API/#Core.Type-Tuple","page":"Package API","title":"Core.Type","text":"Generic constructor for a DynamicalModel's underlying ODEFunctions.\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.Abstract_DynamicalModel-Tuple","page":"Package API","title":"OrbitalTrajectories.Dynamics.Abstract_DynamicalModel","text":"Generic model function.\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.STM_ODEFunction-Union{Tuple{var\"##254\"}, Tuple{Type{OrbitalTrajectories.Dynamics.HasJacobian{var\"##254\"}},ModelingToolkit.AbstractODESystem,var\"##254\"}} where var\"##254\"","page":"Package API","title":"OrbitalTrajectories.Dynamics.STM_ODEFunction","text":"Function to generate an ODE Function that computes the State Transition\nMatrix simultaneously with the given function f. This requires f to have\na computable Jacobian function.\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.centrifugal_potential-Tuple{Any,Any}","page":"Package API","title":"OrbitalTrajectories.Dynamics.centrifugal_potential","text":"Centrifugal potential [DeiTos2017, Eq.13; Ichinomiya 2018, Eq. 2.2]\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.elliptical_potential-NTuple{4,Any}","page":"Package API","title":"OrbitalTrajectories.Dynamics.elliptical_potential","text":"Elliptical potential in barycentric frame [DeiTos2017, Eq. 15]\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.hill_sphere_radius-Tuple{Abstract_R3BPModel}","page":"Package API","title":"OrbitalTrajectories.Dynamics.hill_sphere_radius","text":"Compute the Hill sphere radius for two bodies\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.jacobi-Tuple{Any,Any,Any}","page":"Package API","title":"OrbitalTrajectories.Dynamics.jacobi","text":"Jacobi integral = 2U - V^2 = -2E [Oshima 2019, Eq. 3; Koon, Eq. 2.3.13; Wakker, Eq. 3.54]\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.pos_to_inertial-Tuple{Any}","page":"Package API","title":"OrbitalTrajectories.Dynamics.pos_to_inertial","text":"Returns the position rotation matrix from a rotating 3BP frame to an inertial frame. \n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.sensitivity-Tuple{Module,Vararg{Any,N} where N}","page":"Package API","title":"OrbitalTrajectories.Dynamics.sensitivity","text":"Sensitivity of the final state with respect to initial state. \n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.sensitivity_trace-Tuple{Module,Vararg{Any,N} where N}","page":"Package API","title":"OrbitalTrajectories.Dynamics.sensitivity_trace","text":"Sensitivity of the full propagated trajectory with respect to initial state. \n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.Dynamics.state_to_inertial-Tuple{Any}","page":"Package API","title":"OrbitalTrajectories.Dynamics.state_to_inertial","text":"Returns the state rotation matrix from a rotating 3BP frame to an inertial frame. \n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.SpiceUtils.dynamic_synodic_frame-Tuple{Symbol,Symbol}","page":"Package API","title":"OrbitalTrajectories.SpiceUtils.dynamic_synodic_frame","text":"Automatically build and return a dynamic frame for a synodic reference (b1 is the observer, b2 is the target).\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.SpiceUtils.get_GM-Tuple{String}","page":"Package API","title":"OrbitalTrajectories.SpiceUtils.get_GM","text":"Get body gravitational constant (GM) from SPICE kernels\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.SpiceUtils.get_pos-Tuple{Any,Any,Any}","page":"Package API","title":"OrbitalTrajectories.SpiceUtils.get_pos","text":"Get a target body position from SPICE kernels.\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.SpiceUtils.get_state-Tuple{Any,Any,Any}","page":"Package API","title":"OrbitalTrajectories.SpiceUtils.get_state","text":"Get a target body state from SPICE kernels\n\n\n\n\n\n","category":"method"},{"location":"API/#OrbitalTrajectories.SpiceUtils.mass_fraction-Tuple{Symbol,Symbol}","page":"Package API","title":"OrbitalTrajectories.SpiceUtils.mass_fraction","text":"Get the mass fraction of two bodies (smaller mass divided by total mass)\n\n\n\n\n\n","category":"method"}]
}
